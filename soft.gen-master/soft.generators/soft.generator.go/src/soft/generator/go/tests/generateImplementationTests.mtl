[**
 * This file is part of soft.generator.go, a project for go code 
 * generation of an ecore model
 *
 * Copyright(c) 2021 MASA Group
 *	
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
**/]

[comment encoding = UTF-8 /]
[module generateImplementationTests('http://www.eclipse.org/emf/2002/Ecore')/]

[import soft::generator::common::generateCommon/]
[import soft::generator::common::generateElement/]
[import soft::generator::common::generateReflectives/]
[import soft::generator::common::generateStructuralFeature/]

[import soft::generator::go::generateCommon/]
[import soft::generator::go::generateType/]

[import soft::generator::go::lib::generateCommon/]
[import soft::generator::go::lib::generateReflectives/]
[import soft::generator::go::lib::generateOperation/]
[import soft::generator::go::lib::generateStructuralFeature/]

[query private isFeatureMap(aStructuralFeature : EStructuralFeature) : Boolean = isListType() and eType.name = 'EFeatureMapEntry'/]

[template public generateImplementationTests(aClass : EClass) { 
	implementationName : String = aClass.getImplementationName(); 
	aPackage : EPackage = aClass.ePackage;
	requiresEcore : Boolean = not aPackage.isEcorePackage() and ( aClass.getImplementedFeatures()->notEmpty() or aClass.requiresList() );
}]
[file (aClass.ePackage.getOutputDirectory() + '/' + aClass.getImplementationTestFileName( aClass.name ), false, 'UTF-8')]
[fileComment()/]

package [aPackage.name/]



import (
	"testing"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
[let imports : OrderedSet(String) = Set { if requiresEcore then Set{ aPackage.getImportForPackage('ecore') } else Set{} endif
										, OrderedSet{aClass.eSuperTypes
              									    ,aClass.getImplementedFeatures().eType}->flatten()->select( cls | not cls.oclIsUndefined() )->collect( cls | aPackage.getImport(cls) )->asSet()
                                        }->flatten()->select( s | s <> '')->asOrderedSet()->sortedBy( s | s) ]
[for ( i : String | imports )]
	"[i/]"
[/for]
[/let]
)

func discard[name.toUpperFirst()/]() {
	_ = assert.Equal
	_ = mock.Anything
	_ = testing.Coverage
[if requiresEcore]
	_ = ecore.ADD
[/if]
}

func Test[aClass.name.toUpperFirst()/]As[aClass.name.toUpperFirst()/](t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Equal(t, o , o.as[aClass.getInterfaceName()/]())
}

func Test[aClass.name.toUpperFirst()/]StaticClass(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Equal(t, GetPackage().[aClass.getReflectiveGetterName()/]() , o.EStaticClass() )
}

func Test[aClass.name.toUpperFirst()/]FeatureCount(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Equal(t, [if aClass.isReflectiveDelegation()]0[else][aClass.getFeatureCountIDName()/][/if] , o.EStaticFeatureCount())
}
[if aClass.isMapEntry()]

func Test[aClass.name.toUpperFirst()/]GetKey(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Equal(t, o.[aClass.getEStructuralFeature('key').getGetterName()/]() , o.GetKey())
}

func Test[aClass.name.toUpperFirst()/]GetValue(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Equal(t, o.[aClass.getEStructuralFeature('value').getGetterName()/]() , o.GetValue())
}
[/if]

[aClass.getImplementedFeatures()->sortedBy( getVariableName() ).generateTestFeature(aClass)/]
[aClass.getImplementedOperations()->sortedBy( getOperationName() )->select(isDefault()).generateTestOperation(aClass)/]
[if not aClass.isReflectiveDelegation()]
[aClass.generateElementIDTestImplementation()/]
[aClass.generateEGetFromIDTestImplementation()/]
[aClass.generateESetFromIDTestImplementation()/]
[aClass.generateEIsSetFromIDTestImplementation()/]
[aClass.generateEUnSetFromIDTestImplementation()/]
[aClass.generateEInvokeFromIDTestImplementation()/]
[aClass.generateEInverseAddTestImplementation()/]
[aClass.generateEInverseRemoveTestImplementation()/]
[/if]
[/file]
[/template]

[template private generateTestFeature(aStructuralFeature : EStructuralFeature, aClass : EClass )]
[if isGet()]

[aStructuralFeature.generateGetTestImplementation(aClass)/]
[/if]
[if isSet()]

[aStructuralFeature.generateSetTestImplementation(aClass)/]
[/if]
[if isBasicSet() and not isReflectiveDelegation()]

[aStructuralFeature.generateBasicSetTestImplementation(aClass)/]
[/if]
[if isUnSet()]

[aStructuralFeature.generateUnSetTestImplementation(aClass)/]
[/if]
[/template]

[template private generateTestOperation(anEOperation : EOperation, aClass : EClass )]
[let aPackage : EPackage = aClass.ePackage ]
func Test[aClass.name.toUpperFirst()/][anEOperation.getOperationName()/]Operation(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Panics(t, func() { o.[anEOperation.getOperationName()/]([for (eClassifier : EClassifier | anEOperation.eParameters.eType) separator(',')][eClassifier.getDefaultValue(aClass)/][/for]) })
}
[/let]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isVolatile())]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Get(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Panics(t, func() { o.[aStructuralFeature.getGetterName()/]() })
}
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isContainer())]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Get(t *testing.T) {
	// default
	o := [aClass.getConstructorName()/]()
	assert.Nil(t, o.[aStructuralFeature.getGetterName()/]())

	// set a mock container
	v := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]
	o.ESetInternalContainer(v,[aClass.getFeatureIDName(aStructuralFeature)/])
	
	// no proxy
	v.On("EIsProxy").Return(false)
	assert.Equal(t,v,o.[aStructuralFeature.getGetterName()/]())
}
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isMapType())]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Get(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.NotNil(t, o.[aStructuralFeature.getGetterName()/]())
}
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isListType())]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Get(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	[if aStructuralFeature.eType.name = 'EFeatureMapEntry']
	assert.Nil(t, o.[aStructuralFeature.getGetterName()/]())
	[else]
	assert.NotNil(t, o.[aStructuralFeature.getGetterName()/]())
	[/if]
}
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EReference) and isLazy())]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Get(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Panics(t, func() { o.[aStructuralFeature.getGetterName()/]() })	
}
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EReference) and isProxy())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Get(t *testing.T) {
	o := [aClass.getConstructorName()/]()

	// get default value
	assert.Nil(t, o.[aStructuralFeature.getGetterName()/]())
	
	// initialize object with a mock value
	mockValue := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]
[if aStructuralFeature.isReflectiveDelegation()]
	[if isContainer()]
	[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
	[let reverseClass : EClass = reverseFeature.eContainingClass]
	mockClass := new([ecorePrefix/]MockEClass)
	mockClass.On("GetFeatureID",GetPackage().[reverseFeature.getReflectiveGetterName()/]()).Return([reverseClass.getFeatureIDName(reverseFeature)/]).Once()
	mockValue.On("EClass").Return(mockClass).Once()
	mockValue.On("EInverseAdd", o, [reverseClass.getFeatureIDName(reverseFeature)/], nil).Return(nil).Once()
	mockValue.On("EResource").Return(nil).Once()
	[/let]
	[/let]
	[elseif isContains()]
	mockValue.On("EInverseAdd",o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(aStructuralFeature)/],mock.Anything).Return(nil).Once()
	[elseif isBidirectional()]
	[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
	[let reverseClass : EClass = reverseFeature.eContainingClass]
	mockClass := new([ecorePrefix/]MockEClass)
	mockClass.On("GetFeatureID",GetPackage().[reverseFeature.getReflectiveGetterName()/]()).Return([reverseClass.getFeatureIDName(reverseFeature)/]).Once()
	mockValue.On("EClass").Return(mockClass).Once()
	mockValue.On("EInverseAdd",o,[reverseClass.getQualifiedIDName(reverseFeature)/],nil).Return(nil).Once()
	[/let]
	[/let]
	[/if]
	o.[aStructuralFeature.getSetterName()/](mockValue)
	[if isContainer() or isBidirectional()]
	mock.AssertExpectationsForObjects(t, mockValue, mockClass)
	[/if]
[else]
	o.[aStructuralFeature.getVariableName()/] = mockValue
[/if]

	// events
	mockAdapter := new([ecorePrefix/]MockEAdapter)
	mockAdapter.On("SetTarget", o).Once()
	o.EAdapters().Add(mockAdapter)
	mock.AssertExpectationsForObjects(t, mockAdapter)

	// set object resource
	mockResourceSet := new([ecorePrefix/]MockEResourceSet)
	mockResource := new([ecorePrefix/]MockEResource)
	o.ESetInternalResource(mockResource)

	// get non resolved value
	mockValue.On("EIsProxy").Return(false).Once()
	assert.Equal(t,mockValue,o.[aStructuralFeature.getGetterName()/]())
	mock.AssertExpectationsForObjects(t, mockValue,mockAdapter,mockResource,mockResourceSet)

	// get a resolved value
	mockURI := [ecorePrefix/]NewURI("test:///file.t")
	mockResolved := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]
	mockResolved.On("EProxyURI").Return(nil).Once()
	mockResource.On("GetResourceSet").Return(mockResourceSet).Once()
	mockResourceSet.On("GetEObject",mockURI,true).Return(mockResolved).Once()
	mockValue.On("EIsProxy").Return(true).Once()
	mockValue.On("EProxyURI").Return(mockURI).Twice()
	mockAdapter.On("NotifyChanged", mock.MatchedBy(func(notification [ecorePrefix/]ENotification) bool {
		return notification.GetEventType() == [ecorePrefix/]RESOLVE && notification.GetFeatureID() == [aClass.getFeatureIDName(aStructuralFeature)/] && notification.GetOldValue() == mockValue && notification.GetNewValue() == mockResolved
	})).Once()
	assert.Equal(t,mockResolved,o.[aStructuralFeature.getGetterName()/]())
	mock.AssertExpectationsForObjects(t, mockAdapter,mockValue,mockResolved,mockAdapter,mockResource,mockResourceSet)
}
[/let]
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EReference))]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Get(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	// get default value
	assert.Nil(t, o.[aStructuralFeature.getGetterName()/]())

	// get initialized value
	v := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]
[if aStructuralFeature.isReflectiveDelegation()]
	o.[aStructuralFeature.getSetterName()/](v)
[else]
	o.[aStructuralFeature.getVariableName()/] = v
[/if]
	assert.Equal(t,v,o.[aStructuralFeature.getGetterName()/]())
}
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (oclIsKindOf(EAttribute))]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Get(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	// get default value
	[let aAttribute : EAttribute = aStructuralFeature.oclAsType(EAttribute)]
	[let aDefaultValue : String = aAttribute.getDefaultValueWithType(aClass)]
	[if aDefaultValue = 'nil']
	assert.Nil(t, o.[aAttribute.getGetterName()/]())
	[else]
	assert.Equal(t, [aDefaultValue/], o.[aAttribute.getGetterName()/]())
	[/if]
	[/let]
	[/let]
	// get initialized value
	v := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]	
[if aStructuralFeature.isReflectiveDelegation()]
	o.[aStructuralFeature.getSetterName()/](v)
[else]
	o.[aStructuralFeature.getVariableName()/] = v
[/if]
	assert.Equal(t,v,o.[aStructuralFeature.getGetterName()/]())
}
[/template]

[template private generateGetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isVolatile())]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Set(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	v := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]	
	assert.Panics(t, func() { o.[aStructuralFeature.getSetterName()/](v) })
}
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isReflectiveDelegation() and isContainer())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Set(t *testing.T) {
	// object
	o := [aClass.getConstructorName()/]()

	// add listener
	mockAdapter := new([ecorePrefix/]MockEAdapter)
	mockAdapter.On("SetTarget", o).Once()
	o.EAdapters().Add(mockAdapter)
	mock.AssertExpectationsForObjects(t, mockAdapter)

	// set with the mock value
	mockValue := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]	
	mockResource := new([ecorePrefix/]MockEResource)
	mockClass := new([ecorePrefix/]MockEClass)
	mockValue.On("EClass").Return(mockClass).Once()
	mockClass.On("GetFeatureID",GetPackage().[reverseFeature.getReflectiveGetterName()/]()).Return([reverseClass.getFeatureIDName(reverseFeature)/]).Once()	
	mockValue.On("EInverseAdd", o, [reverseClass.getFeatureIDName(reverseFeature)/], nil).Return(nil).Once()
	mockValue.On("EResource").Return(mockResource).Once()
	mockResource.On("Attached", o).Once()
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	o.[aStructuralFeature.getSetterName()/](mockValue)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockClass, mockValue, mockResource[if isReflectiveDelegation()],mockClass[/if])

	// set with the same mock value
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	o.[aStructuralFeature.getSetterName()/](mockValue)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockClass, mockValue, mockResource)

	// another value - in a different resource
	mockValue2 := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]	
	mockResource2 := new([ecorePrefix/]MockEResource)
	mockValue.On("EClass").Return(mockClass).Once()
	mockClass.On("GetFeatureID",GetPackage().[reverseFeature.getReflectiveGetterName()/]()).Return([reverseClass.getFeatureIDName(reverseFeature)/]).Once()	
	mockValue.On("EInverseRemove", o, [reverseClass.getFeatureIDName(reverseFeature)/], nil).Return(nil).Once()
	mockValue.On("EResource").Return(mockResource).Once()
	mockValue2.On("EClass").Return(mockClass).Once()
	mockClass.On("GetFeatureID",GetPackage().[reverseFeature.getReflectiveGetterName()/]()).Return([reverseClass.getFeatureIDName(reverseFeature)/]).Once()
	mockValue2.On("EInverseAdd", o, [reverseClass.getFeatureIDName(reverseFeature)/], nil).Return(nil).Once()
	mockValue2.On("EResource").Return(mockResource2).Once()
	mockResource.On("Detached", o).Once()
	mockResource2.On("Attached", o).Once()
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	o.[aStructuralFeature.getSetterName()/](mockValue2)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockClass, mockValue, mockResource, mockValue2, mockResource2)
}
[/let]
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isContainer())]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Set(t *testing.T) {
	// object
	o := [aClass.getConstructorName()/]()

	// add listener
	mockAdapter := new([ecorePrefix/]MockEAdapter)
	mockAdapter.On("SetTarget", o).Once()
	o.EAdapters().Add(mockAdapter)
	mock.AssertExpectationsForObjects(t, mockAdapter)

	// set with the mock value
	mockValue := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]	
	mockResource := new([ecorePrefix/]MockEResource)
	mockValue.On("EInverseAdd", o, [reverseClass.getFeatureIDName(reverseFeature)/], nil).Return(nil).Once()
	mockValue.On("EResource").Return(mockResource).Once()
	mockResource.On("Attached", o).Once()
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	o.[aStructuralFeature.getSetterName()/](mockValue)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockValue, mockResource)

	// set with the same mock value
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	o.[aStructuralFeature.getSetterName()/](mockValue)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockValue, mockResource)

	// another value - in a different resource
	mockValue2 := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]	
	mockResource2 := new([ecorePrefix/]MockEResource)
	mockValue.On("EInverseRemove", o, [reverseClass.getFeatureIDName(reverseFeature)/], nil).Return(nil).Once()
	mockValue.On("EResource").Return(mockResource).Once()
	mockValue2.On("EInverseAdd", o, [reverseClass.getFeatureIDName(reverseFeature)/], nil).Return(nil).Once()
	mockValue2.On("EResource").Return(mockResource2).Once()
	mockResource.On("Detached", o).Once()
	mockResource2.On("Attached", o).Once()
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	o.[aStructuralFeature.getSetterName()/](mockValue2)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockValue, mockResource, mockValue2, mockResource2)
}
[/let]
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isReflectiveDelegation() and isBidirectional())]
[let aPackage : EPackage = aClass.ePackage ]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Set(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	
	// add listener
	mockAdapter := new([ecorePrefix/]MockEAdapter)
	mockAdapter.On("SetTarget", o).Once()
	o.EAdapters().Add(mockAdapter)
	mock.AssertExpectationsForObjects(t, mockAdapter)

	// first value
	mockValue1 := [aStructuralFeature.eType.getTestValue(aPackage)/]
	mockClass := new([ecorePrefix/]MockEClass)
	mockValue1.On("EClass").Return(mockClass).Once()
	mockClass.On("GetFeatureID",GetPackage().[reverseFeature.getReflectiveGetterName()/]()).Return([reverseClass.getFeatureIDName(reverseFeature)/]).Once()	
	mockValue1.On("EInverseAdd",o,[reverseClass.getQualifiedIDName(reverseFeature)/],nil).Return(nil).Once()	
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	o.[aStructuralFeature.getSetterName()/](mockValue1)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockValue1,mockClass)

	// second value
	mockValue2 := [aStructuralFeature.eType.getTestValue(aPackage)/]
	mockValue1.On("EClass").Return(mockClass).Once()
	mockClass.On("GetFeatureID",GetPackage().[reverseFeature.getReflectiveGetterName()/]()).Return([reverseClass.getFeatureIDName(reverseFeature)/]).Once()
	mockValue1.On("EInverseRemove",o,[reverseClass.getQualifiedIDName(reverseFeature)/],nil).Return(nil).Once()
	mockValue2.On("EClass").Return(mockClass).Once()
	mockClass.On("GetFeatureID",GetPackage().[reverseFeature.getReflectiveGetterName()/]()).Return([reverseClass.getFeatureIDName(reverseFeature)/]).Once()
	mockValue2.On("EInverseAdd",o,[reverseClass.getQualifiedIDName(reverseFeature)/],nil).Return(nil).Once()	
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	o.[aStructuralFeature.getSetterName()/](mockValue2)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockValue1,mockValue2,mockClass)
}
[/let]
[/let]
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isBidirectional())]
[let aPackage : EPackage = aClass.ePackage ]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Set(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	
	// add listener
	mockAdapter := new([ecorePrefix/]MockEAdapter)
	mockAdapter.On("SetTarget", o).Once()
	o.EAdapters().Add(mockAdapter)
	mock.AssertExpectationsForObjects(t, mockAdapter)

	// first value
	mockValue1 := [aStructuralFeature.eType.getTestValue(aPackage)/]
	mockValue1.On("EInverseAdd",o,[reverseClass.getQualifiedIDName(reverseFeature)/],nil).Return(nil).Once()	
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	o.[aStructuralFeature.getSetterName()/](mockValue1)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockValue1)

	// second value
	mockValue2 := [aStructuralFeature.eType.getTestValue(aPackage)/]
	mockValue1.On("EInverseRemove",o,[reverseClass.getQualifiedIDName(reverseFeature)/],nil).Return(nil).Once()
	mockValue2.On("EInverseAdd",o,[reverseClass.getQualifiedIDName(reverseFeature)/],nil).Return(nil).Once()	
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	o.[aStructuralFeature.getSetterName()/](mockValue2)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockValue1,mockValue2)
}
[/let]
[/let]
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isContains())]
[let aPackage : EPackage = aClass.ePackage ]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Set(t *testing.T) {
	o := [aClass.getConstructorName()/]()

	// add listener
	mockAdapter := new([ecorePrefix/]MockEAdapter)
	mockAdapter.On("SetTarget", o).Once()
	o.EAdapters().Add(mockAdapter)
	mock.AssertExpectationsForObjects(t, mockAdapter)	

	mockValue1 := [aStructuralFeature.eType.getTestValue(aPackage)/]
	mockValue1.On("EInverseAdd",o,[ecorePrefix/]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(aStructuralFeature)/],mock.Anything).Return(nil).Once()
	mockAdapter.On("NotifyChanged", mock.Anything).Once()	
	o.[aStructuralFeature.getSetterName()/](mockValue1)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockValue1)

	// second value
	mockValue2 := [aStructuralFeature.eType.getTestValue(aPackage)/]
	mockValue1.On("EInverseRemove",o,[ecorePrefix/]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(aStructuralFeature)/],nil).Return(nil).Once()
	mockValue2.On("EInverseAdd",o,[ecorePrefix/]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(aStructuralFeature)/],nil).Return(nil).Once()	
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	o.[aStructuralFeature.getSetterName()/](mockValue2)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockValue1,mockValue2)
	
}
[/let]
[/let]
[/template]

[template private generateSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let aPackage : EPackage = aClass.ePackage ]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]Set(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	v := [aStructuralFeature.eType.getTestValue(aPackage)/]	
	mockAdapter := new([getShortQualifiedName('ecore.MockEAdapter',aPackage.name)/])
	mockAdapter.On("SetTarget",o).Once()		
	mockAdapter.On("NotifyChanged", mock.Anything).Once()
	o.EAdapters().Add(mockAdapter)
	o.[aStructuralFeature.getSetterName()/](v)
	mockAdapter.AssertExpectations(t)
}
[/let]
[/template]

[template private generateBasicSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ]
[let aPackage : EPackage = aClass.ePackage ]
[let ecorePrefix : String = if not aPackage.isEcorePackage() then 'ecore.' else '' endif]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]BasicSet(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	
	// add listener
	mockAdapter := new([ecorePrefix/]MockEAdapter)
	mockAdapter.On("SetTarget", o).Once()
	o.EAdapters().Add(mockAdapter)
	mock.AssertExpectationsForObjects(t, mockAdapter)

	mockValue := [aStructuralFeature.eType.getTestValue(aPackage)/]	
	mockNotifications := new([ecorePrefix/]MockENotificationChain)
[if isContainer()]
	mockValue.On("EResource").Return(nil).Once()
[/if]
	mockNotifications.On("Add", mock.MatchedBy(func(notification [ecorePrefix/]ENotification) bool {
		return notification.GetEventType() == [ecorePrefix/]SET && notification.GetFeatureID() == [aClass.getFeatureIDName(aStructuralFeature)/]
	})).Return(true).Once()
	o.basic[aStructuralFeature.getSetterName().toUpperFirst()/](mockValue,mockNotifications)
	mock.AssertExpectationsForObjects(t, mockAdapter, mockValue, mockNotifications)
}
[/let]
[/let]
[/template]

[template private generateUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isVolatile())]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]UnSet(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Panics(t, func() { o.[aStructuralFeature.getUnSetterName()/]() })
}
[/template]

[template private generateUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass) ? (isListType())]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]UnSet(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	o.[aStructuralFeature.getUnSetterName()/]()
	l := o.[aStructuralFeature.getGetterName()/]()
	assert.True(t,l.Empty())
}
[/template]

[template private generateUnSetTestImplementation(aStructuralFeature : EStructuralFeature,aClass : EClass)]
[let ecorePrefix : String = if not aClass.ePackage.isEcorePackage() then 'ecore.' else '' endif]
func Test[aClass.name.toUpperFirst()/][aStructuralFeature.name.toUpperFirst()/]UnSet(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	mockAdapter := new([ecorePrefix/]MockEAdapter)
	mockAdapter.On("SetTarget",o).Once()		
	o.EAdapters().Add(mockAdapter)

	mockAdapter.On("NotifyChanged", mock.MatchedBy(func(notification [ecorePrefix/]ENotification) bool {
		return notification.GetEventType() == [ecorePrefix/]UNSET && notification.GetFeatureID() == [aClass.getFeatureIDName(aStructuralFeature)/]
	})).Once()
	o.[aStructuralFeature.getUnSetterName()/]()
[let defaultValue : String = aStructuralFeature.getDefaultValueWithType(aClass)]
[if defaultValue = 'nil']
	assert.Nil(t, o.[aStructuralFeature.getGetterName()/]())
[else]
	assert.Equal(t, [defaultValue/], o.[aStructuralFeature.getGetterName()/]())
[/if]
[/let]
	mock.AssertExpectationsForObjects(t, mockAdapter)
}
[/let]
[/template]

[template private generateElementIDTestImplementation(aClass : EClass)]
[let aPackage : EPackage = aClass.ePackage]
[let mixinClasses : Set(EClass) = aClass.getMixinClasses()]
[if mixinClasses->exists( c : EClass | c.getImplementedFeatures()->notEmpty())] 
func Test[aClass.name.toUpperFirst()/]EDerivedFeatureID(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	{
		eClass := new([if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockEClass)
		assert.Equal(t,1, o.EDerivedFeatureID(eClass,1) )
	}
[for (aMixinClass : EClass | mixinClasses)]
	{
		eClass := GetPackage().Get[aMixinClass.getElementAccessorName()/]()
		assert.Equal(t,-1, o.EDerivedFeatureID(eClass, -1))
	[for (aFeature : EStructuralFeature | aMixinClass.getImplementedFeatures() )]
		assert.Equal(t,[aClass.getQualifiedIDName(aFeature)/], o.EDerivedFeatureID(eClass, [aMixinClass.getQualifiedIDName(aFeature)/]))
	[/for]
	}
[/for]
}
[/if]

[if mixinClasses->exists( c : EClass | c.getImplementedOperations()->notEmpty())]
func Test[aClass.name.toUpperFirst()/]EDerivedOperationID(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	{
		eClass := new([if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockEClass)
		assert.Equal(t,1, o.EDerivedOperationID(eClass,1) )
	}
[for (aMixinClass : EClass | mixinClasses)]
	{
		eClass := GetPackage().Get[aMixinClass.getElementAccessorName()/]()
		assert.Equal(t,-1, o.EDerivedOperationID(eClass, -1))
	[for (aOperation : EOperation | aMixinClass.getImplementedOperations() )]
		assert.Equal(t,[aClass.getQualifiedIDName(aOperation)/], o.EDerivedOperationID(eClass, [aMixinClass.getQualifiedIDName(aOperation)/]))
	[/for]
	}
[/for]
}
[/if]
[/let]
[/let]
[/template]

[template private generateEGetFromIDTestImplementation(aClass : EClass)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEGetFeatures()->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EGetFromID(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Panics(t, func() { o.EGetFromID(-1, true) })
	[for (anStructFeature : EStructuralFeature | features )]
	[if anStructFeature.isVolatile() or ( anStructFeature.hasInitializationMethod() and anStructFeature.oclIsKindOf(EReference) and not anStructFeature.isListType() and not anStructFeature.isProxy() )  ]
	assert.Panics(t, func() { o.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], true) })
	assert.Panics(t, func() { o.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false) })
	[else]
	assert.Equal(t, o.[anStructFeature.getGetterName()/](), o.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], true))
	[if (not anStructFeature.isMapType() and anStructFeature.isListType() and anStructFeature.oclIsKindOf(EReference))]
	assert.Equal(t, o.[anStructFeature.getGetterName()/]().([if not aClass.ePackage.isEcorePackage()]ecore.[/if]EObjectList).GetUnResolvedList(), o.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false))
	[/if]
	[/if]
    [/for]
}
[/if]
[/let]
[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isVolatile())]
assert.Panics(t, func() { o.ESetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], nil) })

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isContainer())]
{
[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
	mockValue := [anStructuralFeature.eType.getTestValue(aClass.ePackage)/]
	mockValue.On("EIsProxy").Return(false).Once()
	mockValue.On("EResource").Return(nil).Once()
	mockValue.On("EInverseAdd",o,[reverseClass.getQualifiedIDName(reverseFeature)/],nil).Return(nil).Once() 
	o.ESetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], mockValue)
	assert.Equal(t,mockValue,o.EGetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], false))
	mock.AssertExpectationsForObjects(t, mockValue)
[/let]
[/let]	
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isMapType() and anStructuralFeature.eType.oclIsKindOf(EClass) and anStructuralFeature.eType.oclAsType(EClass).isMapEntry())]
{
[let aPackage : EPackage = aClass.ePackage]
[let ecorePrefix : String = if not aPackage.isEcorePackage() then 'ecore.' else '' endif]
[let aMapClass : EClass = anStructuralFeature.eType.oclAsType(EClass)]
[let keyFeature : EStructuralFeature = aMapClass.getEStructuralFeature('key')]
[let valueFeature : EStructuralFeature = aMapClass.getEStructuralFeature('value')]
	// list with a value
	mockMap := &[ecorePrefix/]MockEMap{}
	mockEntry := &[ecorePrefix/]MockEMapEntry{}
	mockIterator := &[ecorePrefix/]MockEIterator{}
	mockKey := [keyFeature.eType.getTestValue(aPackage)/]
	mockValue := [valueFeature.eType.getTestValue(aPackage)/]		
	mockMap.On("Iterator").Return(mockIterator).Once()
	mockIterator.On("HasNext").Return(true).Once()
	mockIterator.On("Next").Return(mockEntry).Once()
	mockIterator.On("HasNext").Return(false).Once()
	mockEntry.On("GetKey").Return(mockKey).Once()
	mockEntry.On("GetValue").Return(mockValue).Once()
	
	// set list with new contents
	o.ESetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], mockMap)
	assert.Equal(t, map['['/]interface{}[']'/]interface{}{mockKey : mockValue},o.[anStructuralFeature.getGetterName()/]().ToMap())
	mock.AssertExpectationsForObjects(t, mockMap, mockEntry)
[/let]
[/let]
[/let]
[/let]
[/let]
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isMapType())]
[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isListType() and oclIsKindOf(EReference))]
{
	// list with a value
	mockValue := [anStructuralFeature.eType.getTestValue(aClass.ePackage)/]
	l := [if not aClass.ePackage.isEcorePackage()]ecore.[/if]NewImmutableEList(['['/][']'/]interface{}{mockValue})
[if anStructuralFeature.isProxy()]
	mockValue.On("EIsProxy").Return(false).Once()
[/if]
	[anStructuralFeature.generateFeatureMockAddedExpectations('mockValue',aClass)/]
	// set list with new contents
	o.ESetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], l)
	// checks
	assert.Equal(t, 1, o.[anStructuralFeature.getGetterName()/]().Size())
	assert.Equal(t, mockValue, o.[anStructuralFeature.getGetterName()/]().Get(0))
	mock.AssertExpectationsForObjects(t, mockValue)	
}

[/template]

[template private generateFeatureMockAddedExpectations(anStructuralFeature : EStructuralFeature , mockName : String , aClass : EClass)]
[if anStructuralFeature.isContains()]
	[let anEReference : EReference = anStructuralFeature.oclAsType(EReference)]
	[if anEReference.eOpposite.oclIsUndefined()]
[mockName/].On("EInverseAdd",o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(anStructuralFeature)/],mock.Anything).Return(nil).Once()
	[else]
	[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
	[let reverseClass : EClass = reverseFeature.eContainingClass]
[mockName/].On("EInverseAdd",o,[reverseClass.getQualifiedIDName(reverseFeature)/],mock.Anything).Return(nil).Once() 
	[/let]
	[/let]
	[/if]
	[/let]
[elseif anStructuralFeature.oclIsKindOf(EReference)]
	[let anEReference : EReference = anStructuralFeature.oclAsType(EReference)]
	[if anEReference.eOpposite.oclIsUndefined()]
	[else]
	[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
	[let reverseClass : EClass = reverseFeature.eContainingClass]
[mockName/].On("EInverseAdd",o,[reverseClass.getQualifiedIDName(reverseFeature)/],mock.Anything).Return(nil).Once() 
	[/let]
	[/let]
	[/if]
	[/let]
[/if]
[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isListType())]
{
	l := [if not aClass.ePackage.isEcorePackage()]ecore.[/if]NewImmutableEList(['['/][']'/]interface{}{})
	o.ESetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], l)
	assert.True(t, o.[anStructuralFeature.getGetterName()/]().Empty())
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isBidirectional())]
{
[let reverseFeature : EStructuralFeature = anStructuralFeature.oclAsType(EReference).eOpposite]
[let reverseClass : EClass = reverseFeature.eContainingClass]
	mockValue := [anStructuralFeature.eType.getTestValue(aClass.ePackage)/]
	mockValue.On("EInverseAdd",o,[reverseClass.getQualifiedIDName(reverseFeature)/],nil).Return(nil).Once()	
	o.ESetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], mockValue)
	assert.Equal(t,mockValue,o.EGetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], false))
	mock.AssertExpectationsForObjects(t, mockValue)
[/let]
[/let]
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass) ? (isContains())]
{
	mockValue := [anStructuralFeature.eType.getTestValue(aClass.ePackage)/]
	mockValue.On("EInverseAdd",o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(anStructuralFeature)/],mock.Anything).Return(nil).Once()
	o.ESetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], mockValue)
	assert.Equal(t,mockValue,o.EGetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], false))
	mock.AssertExpectationsForObjects(t, mockValue)
}

[/template]

[template private generateFeatureESetFromIDTestImplementation(anStructuralFeature : EStructuralFeature ,aClass : EClass)]
{
	v := [anStructuralFeature.eType.getTestValue(aClass.ePackage)/]	
	o.ESetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], v)
	assert.Equal(t,v,o.EGetFromID([aClass.getQualifiedIDName(anStructuralFeature)/], false))
}

[/template]

[template private generateESetFromIDTestImplementation(aClass : EClass)]
[let aPackage : EPackage = aClass.ePackage ]
[let features : OrderedSet(EStructuralFeature) = aClass.getESetFeatures()->select(not isFeatureMap())->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
[let isMockGenerated : Boolean = ]
func Test[aClass.name.toUpperFirst()/]ESetFromID(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Panics(t, func() { o.ESetFromID(-1, nil) })
	[features.generateFeatureESetFromIDTestImplementation(aClass)/]
}
[/let]
[/if]
[/let]
[/let]
[/template]

[template private generateEInvokeFromIDTestImplementation(aClass : EClass)]
[let operations : OrderedSet(EOperation) = aClass.getEInvokeOperations()->asOrderedSet()->sortedBy( o | o.eContainingClass.getOperationIDName(o))]
[if aClass.name <> 'EObject' and operations->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EInvokeFromID(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Panics(t, func() { o.EInvokeFromID(-1, nil) })
    [for ( eOperation : EOperation | operations )]
    assert.Panics(t, func() { o.EInvokeFromID([eOperation.eContainingClass.getOperationIDName(eOperation)/], nil) })
	[/for]
}
[/if]
[/let]
[/template]

[template private generateEIsSetFromIDTestImplementation(aClass : EClass)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEIsSetFeatures()->select(not isFeatureMap())->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EIsSetFromID(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Panics(t, func() { o.EIsSetFromID(-1) })
	[for (anStructFeature : EStructuralFeature | features)]
		[if anStructFeature.isVolatile()]
		assert.Panics(t, func() { o.EIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/]) })
		[else]
		assert.False(t,o.EIsSetFromID([aClass.getQualifiedIDName(anStructFeature)/]))
		[/if]		
	[/for]
}
[/if]
[/let]
[/template]

[template private generateEUnSetFromIDTestImplementation(aClass : EClass)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEUnSetFeatures()->select(not isFeatureMap())->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EUnsetFromID(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	assert.Panics(t, func() { o.EUnsetFromID(-1) })
    [for (anStructFeature : EStructuralFeature | features)]
	{
	[if anStructFeature.isVolatile()]
		assert.Panics(t, func() { o.EUnsetFromID([aClass.getQualifiedIDName(anStructFeature)/]) })
	[else]
		o.EUnsetFromID([aClass.getQualifiedIDName(anStructFeature)/])
		[if anStructFeature.isListType()]
		v := o.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false)
		assert.NotNil(t,v)
		l := v.([if not aClass.ePackage.isEcorePackage()]ecore.[/if]EList)
		assert.True(t,l.Empty())
		[elseif anStructFeature.oclIsKindOf(EReference)]
		assert.Nil(t,o.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false))
		[else]
			[let aAttribute : EAttribute = anStructFeature.oclAsType(EAttribute)]
			[let defaultValue : String = aAttribute.getDefaultValueWithType(aClass)]
			[if defaultValue <> '']
		v := o.EGetFromID([aClass.getQualifiedIDName(anStructFeature)/], false)
			[if defaultValue = 'nil']
		assert.Nil(t,v)
			[else]
		assert.Equal(t,[defaultValue/],v)
			[/if]	
			[else]
			[/if]
			[/let]
			[/let]
		[/if]
	[/if]
	}
	[/for]
}
[/if]
[/let]
[/template]



[template private generateEInverseAddTestImplementation(aClass : EClass)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEInverseAddFeatures()->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EBasicInverseAdd(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	{
		mockObject := new([if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockEObject)
		mockNotifications := new([if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockENotificationChain)
		assert.Equal(t,mockNotifications,o.EBasicInverseAdd(mockObject,-1,mockNotifications))
	}
	[features.generateFeatureEInverseAddTestImplementation(aClass)/]
}
[/if]
[/let]
[/template]

[template private generateFeatureEInverseAddTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass ) ?(isMapType())]
[/template]

[template private generateFeatureEInverseAddTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass ) ?(isListType())]
{
	mockObject := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]
	o.EBasicInverseAdd(mockObject,[aClass.getQualifiedIDName(aStructuralFeature)/],nil)
	l := o.[aStructuralFeature.getGetterName()/]()
	assert.True(t, l.Contains(mockObject))
	mock.AssertExpectationsForObjects(t, mockObject)
}

[/template]

[template private generateFeatureEInverseAddTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass ) ?(isContainer())]
{
	mockObject := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]
	mockObject.On("EResource").Return(nil).Once()
	mockObject.On("EIsProxy").Return(false).Once()
	o.EBasicInverseAdd(mockObject,[aClass.getQualifiedIDName(aStructuralFeature)/],nil)
	assert.Equal(t, mockObject, o.[aStructuralFeature.getGetterName()/]())
	mock.AssertExpectationsForObjects(t, mockObject)

	mockOther := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]
	mockOther.On("EResource").Return(nil).Once()
	mockOther.On("EIsProxy").Return(false).Once()
	mockObject.On("EResource").Return(nil).Once()
[if aStructuralFeature.isContains()]
	mockObject.On("EInverseRemove",o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(aStructuralFeature)/],nil).Return(nil).Once()
[else]
	[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
	mockObject.On("EInverseRemove",o,[reverseFeature.eContainingClass.getQualifiedIDName(reverseFeature)/],nil).Return(nil).Once()
	[/let]
[/if]
	o.EBasicInverseAdd(mockOther,[aClass.getQualifiedIDName(aStructuralFeature)/],nil)
	assert.Equal(t, mockOther, o.[aStructuralFeature.getGetterName()/]())
	mock.AssertExpectationsForObjects(t, mockObject,mockOther)
}

[/template]

[template private generateFeatureEInverseAddTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass )]
{
	mockObject := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]
[if aStructuralFeature.isProxy()]
	mockObject.On("EIsProxy").Return(false)
[/if]
	o.EBasicInverseAdd(mockObject,[aClass.getQualifiedIDName(aStructuralFeature)/],nil)
	assert.Equal(t, mockObject, o.[aStructuralFeature.getGetterName()/]())
	mock.AssertExpectationsForObjects(t, mockObject)

	mockObject2 := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]
[if aStructuralFeature.isProxy()]
	mockObject2.On("EIsProxy").Return(false)
[/if]
[if aStructuralFeature.isContains()]
	mockObject.On("EInverseRemove",o,[if not aClass.ePackage.isEcorePackage()]ecore.[/if]EOPPOSITE_FEATURE_BASE - [aClass.getQualifiedIDName(aStructuralFeature)/],nil).Return(nil).Once()
[else]
	[let reverseFeature : EStructuralFeature = aStructuralFeature.oclAsType(EReference).eOpposite]
	mockObject.On("EInverseRemove",o,[reverseFeature.eContainingClass.getQualifiedIDName(reverseFeature)/],nil).Return(nil).Once()
	[/let]
[/if]
	o.EBasicInverseAdd(mockObject2,[aClass.getQualifiedIDName(aStructuralFeature)/],nil)
	assert.Equal(t, mockObject2, o.[aStructuralFeature.getGetterName()/]())
	mock.AssertExpectationsForObjects(t, mockObject2)
}

[/template]

[template private generateEInverseRemoveTestImplementation(aClass : EClass)]
[let features : OrderedSet(EStructuralFeature) = aClass.getEInverseRemoveFeatures()->asOrderedSet()->sortedBy(name)]
[if features->notEmpty()]
func Test[aClass.name.toUpperFirst()/]EBasicInverseRemove(t *testing.T) {
	o := [aClass.getConstructorName()/]()
	{
		mockObject := new([if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockEObject)
		mockNotifications := new([if not aClass.ePackage.isEcorePackage()]ecore.[/if]MockENotificationChain)
		assert.Equal(t,mockNotifications,o.EBasicInverseRemove(mockObject,-1,mockNotifications))
	}
	[features.generateFeatureEInverseRemoveTestImplementation(aClass)/]
}
[/if]
[/let]
[/template]

[template private generateFeatureEInverseRemoveTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass ) ?(isMapType())]
{
	mockObject := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]
	o.EBasicInverseRemove(mockObject,[aClass.getQualifiedIDName(aStructuralFeature)/],nil)
	mock.AssertExpectationsForObjects(t, mockObject)
	assert.True(t,o.[aStructuralFeature.getGetterName()/]().Empty())
}

[/template]

[template private generateFeatureEInverseRemoveTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass ) ?(isListType())]
{
	// initialize list with a mock object
	mockObject := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]
	[aStructuralFeature.generateFeatureMockAddedExpectations('mockObject',aClass)/]
	l := o.[aStructuralFeature.getGetterName()/]()
	l.Add(mockObject)

	// basic inverse remove
	o.EBasicInverseRemove(mockObject,[aClass.getQualifiedIDName(aStructuralFeature)/],nil)

	// check it was removed
	assert.False(t, l.Contains(mockObject))
	mock.AssertExpectationsForObjects(t, mockObject)
}

[/template]

[template private generateFeatureEInverseRemoveTestImplementation( aStructuralFeature : EStructuralFeature, aClass : EClass )]
{
	mockObject := [aStructuralFeature.eType.getTestValue(aClass.ePackage)/]
	o.EBasicInverseRemove(mockObject,[aClass.getQualifiedIDName(aStructuralFeature)/],nil)
	mock.AssertExpectationsForObjects(t, mockObject)
}

[/template]
