[**
 * This file is part of soft.generator.cpp, a project for cpp code 
 * generation of an ecore model
 *
 * Copyright(c) 2021 MASA Group
 *	
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
**/]

[comment encoding = UTF-8 /]
[module generateCMake('http://www.eclipse.org/emf/2002/Ecore')/]

[import soft::generator::cpp::generateCommon/]
[import soft::generator::cpp::generateCMake/]
[import soft::generator::cpp::lib::generateCommon/]

[template public generateLibraryCMakeFiles(aPackage : EPackage) { packageName : String = aPackage.name;}]
[file (getOutputDirectory().concat('/CMakeGenerated.txt'), false, 'UTF-8')]
# Generated sources

[let namespaceVar : String = getVarName( aPackage.getInterfaceNamespaceName() )] 
set(GENERATED_HEADER_[namespaceVar/]_FILES
    src-gen/[packageName/]/Exports.hpp
    src-gen/[namespaceToFolder(aPackage.getFactoryQualifiedInterfaceName())/].hpp
    src-gen/[namespaceToFolder(aPackage.getQualifiedInterfaceName())/].hpp
[for (aClass : EClass | aPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name))]
    src-gen/[namespaceToFolder(aClass.getQualifiedInterfaceName())/].hpp
[/for]
[for (anEEnum : EEnum | aPackage.eAllContents(EEnum))]
    src-gen/[ anEEnum.ePackage.getInterfaceFolder()/]/[anEEnum.name/].hpp    
[/for]
)
set(GENERATED_SOURCE_[namespaceVar/]_FILES
    src-gen/[namespaceToFolder(aPackage.getFactoryQualifiedInterfaceName())/].cpp
    src-gen/[namespaceToFolder(aPackage.getQualifiedInterfaceName())/].cpp
)
[/let]
[let namespaceVar : String = getVarName( aPackage.getImplementationNamespaceName() )] 
set(GENERATED_HEADER_[namespaceVar/]_FILES
    src-gen/[namespaceToFolder(aPackage.getFactoryQualifiedBaseName())/].hpp
    src-gen/[namespaceToFolder(aPackage.getFactoryQualifiedBaseName())/].inl
    src-gen/[namespaceToFolder(aPackage.getFactoryQualifiedImplementationName())/].hpp
    src-gen/[namespaceToFolder(aPackage.getQualifiedBaseName())/].hpp
    src-gen/[namespaceToFolder(aPackage.getQualifiedBaseName())/].inl
    src-gen/[namespaceToFolder(aPackage.getQualifiedImplementationName())/].hpp
[for (aClass : EClass | aPackage.eAllContents(EClass)->asOrderedSet()->sortedBy(name))]
    [if not aClass.interface]
    src-gen/[namespaceToFolder(aClass.getQualifiedBaseName())/].hpp
    src-gen/[namespaceToFolder(aClass.getQualifiedBaseName())/].inl
        [if aClass.hasOnlyImplementationFeatures()]
    src-gen/[namespaceToFolder(aClass.getQualifiedInternalName())/].hpp
        [/if]
    src-gen/[namespaceToFolder(aClass.getQualifiedImplementationName())/].hpp
    [/if]
[/for]
)
[/let]

[/file]
[/template]

[template public generateLibraryCMakeLists(aPackage : EPackage) { packageName : String = aPackage.name;}]
[file (getOutputDirectory().concat('/CMakeLists.txt'), false, 'UTF-8')]
#############################################################################
#                                                                           #
#             CMakeList created by soft.generator.cpp Generator             # 
#                                                                           #
#############################################################################

# C++ project for model [packageName/].ecore, generated by soft.generator.cpp

CMAKE_MINIMUM_REQUIRED(VERSION 3.12)

project([packageName/].lib CXX)

# options
if(NOT CMAKE_BUILD_TYPE) 
    set(CMAKE_BUILD_TYPE Debug)
endif()

set(CMAKE_CXX_STANDARD 17)

# dependencies
[if packageName <> 'ecore']
find_package(Ecore)
[/if]
find_package(XercesC REQUIRED)
find_package(Threads REQUIRED)
find_package(Boost REQUIRED regex)
find_package(Date REQUIRED)

include( CMakeFiles.txt OPTIONAL)
include( CMakeGenerated.txt OPTIONAL)

# cmake files
set(CMAKE_FILES
    CMakeLists.txt
)
if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/CMakeFiles.txt")
   list(APPEND CMAKE_FILES "CMakeFiles.txt")
endif()
if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/CMakeGenerated.txt")
   list(APPEND CMAKE_FILES "CMakeGenerated.txt")
endif()

set(PROJECT_SOURCES ${CMAKE_FILES}
[let namespaces : OrderedSet(String) = Sequence{ getAllNamespaces( aPackage.getInterfaceNamespaceName() ) 
                                               , getAllNamespaces( aPackage.getImplementationNamespaceName() )
                                               , getAllNamespaces( aPackage.getExtensionNamespaceName() )
                                               }->flatten()->asOrderedSet()->sortedBy(s | s)]
[for (variable : String | namespaces->getAllVariables())]
                    [variable/]
[/for]
)
# shared library
add_library([packageName/] SHARED ${PROJECT_SOURCES})
add_library([packageName/]::shared ALIAS [packageName/])
target_include_directories([packageName/]
    PUBLIC
        $<INSTALL_INTERFACE:include>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src-gen>
)
target_compile_options([packageName/] PRIVATE /MP /wd4250 /wd4251 /bigobj)
target_compile_definitions( [packageName/] PRIVATE [packageName.toUpper()/]_EXPORTS)
target_compile_definitions( [packageName/] PRIVATE _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING)
target_link_libraries([packageName/] PUBLIC [if packageName <> 'ecore']Ecore::ecore::shared[/if] XercesC::XercesC Boost::regex)

# static library
add_library([packageName/].static STATIC ${PROJECT_SOURCES})
add_library([packageName/]::static ALIAS [packageName/].static)
target_include_directories([packageName/].static
    PUBLIC
        $<INSTALL_INTERFACE:include>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src>
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/src-gen>
)
target_compile_options([packageName/].static PRIVATE /MP /wd4250 /bigobj)
target_compile_definitions([packageName/].static PUBLIC [packageName.toUpper()/]_STATIC_LIB)
target_compile_definitions([packageName/].static PRIVATE _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING)
target_link_libraries([packageName/].static PUBLIC [if packageName <> 'ecore']Ecore::ecore::static[/if] XercesC::XercesC Boost::regex)

# libraries names
set_target_properties([packageName/].static PROPERTIES PREFIX lib)
set_target_properties([packageName/] [packageName/].static PROPERTIES OUTPUT_NAME [packageName/]-vc${MSVC_TOOLSET_VERSION}-mt$<$<CONFIG:Debug>:-gd>)

[generateSourceGroup(namespaces)/]

#-----------------------------------------------------
# Install binaries and header
#-----------------------------------------------------
include(GNUInstallDirs)
install(TARGETS [packageName/] [packageName/].static
        EXPORT  [packageName/].targets
        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
[for ( namespace : String | namespaces )]
[let namespaceVar : String = getVarName(namespace)]
install(FILES [getVarName('HEADER',namespaceVar,'FILES')/] [getVarName('GENERATED_HEADER',namespaceVar,'FILES')/] DESTINATION include[if namespace<>'']/[namespaceToFolder(namespace)/][/if])
[/let]
[/for]
[/let]

#-----------------------------------------------------
# Package binaries and header
#-----------------------------------------------------
set(CPACK_GENERATOR "ZIP")
set(CPACK_PACKAGE_NAME [packageName/])

include(CPack)
[/file]
[/template]


